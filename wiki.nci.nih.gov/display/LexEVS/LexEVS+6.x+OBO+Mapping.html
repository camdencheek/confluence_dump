<table>
  <tbody>
    <tr>
      <th>
        OBO Class
      </th>
      <th>
        OBO Entity
      </th>
      <th>
        LexGrid Model Element
      </th>
      <th>
        Notes
      </th>
    </tr>
    <tr>
      <td>
        Document Header
      </td>
      <td>
        format-version
      </td>
      <td>
        None
      </td>
      <td>
        Not mapped.
      </td>
    </tr>
    <tr>
      <td>
        Document Header
      </td>
      <td>
        data-version
      </td>
      <td>
        CodingScheme.representsVersion
      </td>
      <td>
        Creates a codingSchemeVersion and SystemRelease record. If not specified, then hard coded &#34;UNASSIGNED&#34;
      </td>
    </tr>
    <tr>
      <td>
        Document Header
      </td>
      <td>
        version
      </td>
      <td>
        CodingScheme.representsVersion
      </td>
      <td>
        Deprecated - use data-version if present.
      </td>
    </tr>
    <tr>
      <td>
        Document Header
      </td>
      <td>
        date
      </td>
      <td>
        None
      </td>
      <td>
        Not mapped.
      </td>
    </tr>
    <tr>
      <td>
        Document Header
      </td>
      <td>
        saved-by
      </td>
      <td>
        None
      </td>
      <td>
        Ignored but included if contained in the remark entity.
      </td>
    </tr>
    <tr>
      <td>
        Document Header
      </td>
      <td>
        auto-generated-by
      </td>
      <td>
        None
      </td>
      <td>
        Ignored but included if contained in the remark entity.
      </td>
    </tr>
    <tr>
      <td>
        Document Header
      </td>
      <td>
        subsetdef
      </td>
      <td>
        None
      </td>
      <td>
        Not mapped.
      </td>
    </tr>
    <tr>
      <td>
        Document Header
      </td>
      <td>
        import
      </td>
      <td>
        None
      </td>
      <td>
        Deprecated - Imports are used to assemble a larger document from smaller.
      </td>
    </tr>
    <tr>
      <td>
        Document Header
      </td>
      <td>
        typeref
      </td>
      <td>
        None
      </td>
      <td>
        Deprecated.
      </td>
    </tr>
    <tr>
      <td>
        Document Header
      </td>
      <td>
        synonymtypedef
      </td>
      <td>
        None
      </td>
      <td>
        Not mapped.
      </td>
    </tr>
    <tr>
      <td>
        Document Header
      </td>
      <td>
        idspace
      </td>
      <td>
        None
      </td>
      <td>
        Not mapped.The idspace is a triple - localName, URN and description.
      </td>
    </tr>
    <tr>
      <td>
        Document Header
      </td>
      <td>
        default-relationship-id-prefix
      </td>
      <td>
        None
      </td>
      <td>
        Not mapped.
      </td>
    </tr>
    <tr>
      <td>
        Document Header
      </td>
      <td>
        id-mapping
      </td>
      <td>
        CodingScheme.supportedAssociation
      </td>
      <td>
        This is more generalized than the LexGrid model, as it supports mapping between *any* id&#39;s. Note that its primary purpose, however, is to handle supportedAssociation.
      </td>
    </tr>
    <tr>
      <td>
        Document Header
      </td>
      <td>
        remark
      </td>
      <td>
        CodingScheme.entityDescription
      </td>
      <td>
        Will combine multiple remark entities into the entityDescription.
      </td>
    </tr>
    <tr>
      <td>
        Document Header
      </td>
      <td>
        default-namespace
      </td>
      <td>
        codingScheme.codingSchemeName
      </td>
      <td>
        Will use default-namespace if provided; otherwise will use filename without the extension.
      </td>
    </tr>
    <tr>
      <td>
        Document Header
      </td>
      <td>
        default-namespace
      </td>
      <td>
        codingScheme.formalName
      </td>
      <td>
        Will use default-namespace if provided; otherwise will use filename without the extension.
      </td>
    </tr>
    <tr>
      <td>
        Document Header
      </td>
      <td>
        default-namespace
      </td>
      <td>
        codingScheme.codingSchemeURI
      </td>
      <td>
        Combination of &#34;urn:lsid:bioontology.org:&#34; and if provided, the value in &#34;default-namespace&#34;; but if not will use filename without the extension.
      </td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>
        codingScheme.defaultLanguage
      </td>
      <td>
        Hardcoded &#34;en&#34;
      </td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>
        codingScheme.isNative
      </td>
      <td>
        Hardcoded &#34;true&#34;
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        id
      </td>
      <td>
        Entity.entityCode
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        name
      </td>
      <td>
        Entity.entityDescription
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>
        Entity.presentation[&#39;textualPresentation&#39;].text
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>
        Entity.presentation[&#39;textualPresentation&#39;].isPreferred = true
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        alt_id
      </td>
      <td>
        Entity.property.property=&#34;alt_id&#34;
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>
        Entity.property[&#39;alt_id&#39;].propertyId
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>
        Entity.property[&#39;alt_id&#39;].text
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        is_anonymous
      </td>
      <td>
        Entity.isAnonymous = true
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        is_obsolete
      </td>
      <td>
        Entity.isActive = false
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        def
      </td>
      <td>
        Entity.definition
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>
        Entity.definition.isPreferred = true
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        def.dbxref
      </td>
      <td>
        None
      </td>
      <td>
        See dbxref
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        comment
      </td>
      <td>
        Entity.comment.text
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        subset
      </td>
      <td>
        property[subset tag]
      </td>
      <td>
        See subsetdef
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        syonym
      </td>
      <td>
        presentation[&#39;textualPresentation&#39;].text
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        synonym.scope
      </td>
      <td>
        presentation[&#39;textualPresentation&#39;].degreeOfFidelity
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        synonym.type
      </td>
      <td>
        presentation[&#39;textualPresentation&#39;].representationalForm
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        synonym.dbxref
      </td>
      <td>
        (see dbxref)
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        exact_synonym
      </td>
      <td>
        None
      </td>
      <td>
        See synonym
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        narrow_synonym
      </td>
      <td>
        None
      </td>
      <td>
        See synonym
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        broad_synonym
      </td>
      <td>
        None
      </td>
      <td>
        See synonym
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        xref
      </td>
      <td>
        Property.[&#39;xref&#39;]
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        xref_analog
      </td>
      <td>
        None
      </td>
      <td>
        See synonym
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        xref_unk
      </td>
      <td>
        None
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        is_a
      </td>
      <td>
        AssociationPredicate.[&#39;is_a&#39;]
      </td>
      <td>
        Reverse of the source and target.
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        is_a.namespace
      </td>
      <td>
        None
      </td>
      <td>
        If present, the supplied namespace becomes the owning &#34;codingScheme&#34;.
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        is_a.derived
      </td>
      <td>
        AssociationPredicate.is_a.AssociationSource.AssociationTarget.associationQualifier
      </td>
      <td>
        If present, need to include derived in the supportedAssociationQualifiers section
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        intersection_of
      </td>
      <td>
        None
      </td>
      <td>
        Processed the same way that OWL intersection operator is processed. This includes creation of anonymous sets.
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        union_of
      </td>
      <td>
        None
      </td>
      <td>
        Same as OWL
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        disjoint_from
      </td>
      <td>
        None
      </td>
      <td>
        Same as OWL
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        relationship
      </td>
      <td>
        associations.
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        relationship.not_necessary
      </td>
      <td>
        AssociationTarget..associationQualifier
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        relationship.inverse_necessary
      </td>
      <td>
        AssociationTarget..associationQualifier
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        relationship.namespace
      </td>
      <td>
        None
      </td>
      <td>
        If present, the supplied namespace becomes the owning &#34;codingScheme&#34;.
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        relationship.derived
      </td>
      <td>
        AssociationTarget..associationQualifier
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        relationship.cardinality
      </td>
      <td>
        AssociationTarget..associationQualifier
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        relationship.maxCardinality
      </td>
      <td>
        AssociationTarget..associationQualifier
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        relationship.minCardinality
      </td>
      <td>
        AssociationTarget..associationQualifier
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        is_obsolete
      </td>
      <td>
        Entity.isActive = false
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td></td>
      <td></td>
      <td>
        Entity.conceptStatus=&#34;is_obsolete&#34;
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        replaced_by
      </td>
      <td>
        None
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        consider
      </td>
      <td>
        None
      </td>
      <td>
        Not Mapped
      </td>
    </tr>
    <tr>
      <td>
        Stanza
      </td>
      <td>
        use_term
      </td>
      <td>
        None
      </td>
      <td>
        (deprecated)
      </td>
    </tr>
    <tr>
      <td>
        dbxref
      </td>
      <td>
        dbxref name
      </td>
      <td>
        Entity.source
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        dbxref
      </td>
      <td>
        dbxref name
      </td>
      <td>
        supportedSource
      </td>
      <td>
        dbxref name format is inconsistent. In most cases, it can be the localName of supportedSource, but special processing may be necessary in the case of URL&#39;s, etc
      </td>
    </tr>
    <tr>
      <td>
        dbxref
      </td>
      <td>
        dbxref description
      </td>
      <td>
        None
      </td>
      <td>
        Not mapped.
      </td>
    </tr>
    <tr>
      <td>
        dbxref
      </td>
      <td>
        trailing modifiers
      </td>
      <td>
        None
      </td>
      <td>
        Not mapped.
      </td>
    </tr>
    <tr>
      <td>
        typeDef Stanza
      </td>
      <td>
        domain
      </td>
      <td>
        AssociationPredicate.[&#39;has_domain&#39;]
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        typeDef Stanza
      </td>
      <td>
        range
      </td>
      <td>
        AssociationPredicate.[&#39;has_range&#39;]
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        typeDef Stanza
      </td>
      <td>
        is_cyclic
      </td>
      <td>
        property[&#39;is_cyclic&#39;]
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        typeDef Stanza
      </td>
      <td>
        is_reflexive
      </td>
      <td>
        property[&#39;is_reflexive&#39;]
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        typeDef Stanza
      </td>
      <td>
        is_reflexive
      </td>
      <td>
        AssociationEntity.isReflexive
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        typeDef Stanza
      </td>
      <td>
        is_symmetric
      </td>
      <td>
        property[&#39;is_symmetric&#39;]
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        typeDef Stanza
      </td>
      <td>
        is_symmetric
      </td>
      <td>
        association.isSymmetric
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        typeDef Stanza
      </td>
      <td>
        is_transitive
      </td>
      <td>
        property[&#39;is_transitive&#39;]
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        typeDef Stanza
      </td>
      <td>
        is_transitive
      </td>
      <td>
        association.isTransitive
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        typeDef Stanza
      </td>
      <td>
        inverse_of
      </td>
      <td>
        association.inverse
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        instance stanza
      </td>
      <td>
        id
      </td>
      <td>
        same rules as general stanza
      </td>
      <td>
        same rules as general stanza
      </td>
    </tr>
    <tr>
      <td>
        instance stanza
      </td>
      <td>
        name
      </td>
      <td>
        same rules as general stanza
      </td>
      <td>
        same rules as general stanza
      </td>
    </tr>
    <tr>
      <td>
        instance stanza
      </td>
      <td>
        instance_of
      </td>
      <td>
        AssociationPredicate[&#39;has_instance&#39;]
      </td>
      <td>
        No notes
      </td>
    </tr>
    <tr>
      <td>
        instance stanza
      </td>
      <td>
        instance_of
      </td>
      <td>
        Entity.property.property=&#34;&#34;
      </td>
      <td>
        data type properties go in Coded Entry property section
      </td>
    </tr>
  </tbody>
</table>