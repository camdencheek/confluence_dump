This section describes the components of the caCORE LexEVS and the service interface layer provided by the EVS API architecture. It gives examples of how to use the EVS APIs. It also describes the Distributed LexBIG API and the Distributed LexBIG Adapter.

Contents of this Page
<ul>
  <li>
    <a href="#InteractingwithcaCORELexEVS3.xand4.x-caCORELexEVSComponents" rel="nofollow">
      caCORE LexEVS Components
    </a>
  </li>
  <li>
    <a href="#InteractingwithcaCORELexEVS3.xand4.x-LexEVSDataSources" rel="nofollow">
      LexEVS Data Sources
    </a>
    <ul>
      <li>
        <a href="#InteractingwithcaCORELexEVS3.xand4.x-NCIThesaurus" rel="nofollow">
          NCI Thesaurus
        </a>
      </li>
      <li>
        <a href="#InteractingwithcaCORELexEVS3.xand4.x-NCIMetathesaurus" rel="nofollow">
          NCI Metathesaurus
        </a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#InteractingwithcaCORELexEVS3.xand4.x-InstallingandConfiguringtheLexEVS5.0JavaAPI" rel="nofollow">
      Installing and Configuring the LexEVS 5.0 Java API
    </a>
    <ul>
      <li>
        <a href="#InteractingwithcaCORELexEVS3.xand4.x-SoftwareRequirements" rel="nofollow">
          Software Requirements
        </a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#InteractingwithcaCORELexEVS3.xand4.x-DownloadingtheJavaAPIClientPackage" rel="nofollow">
      Downloading the Java API Client Package
    </a>
    <ul>
      <li>
        <a href="#InteractingwithcaCORELexEVS3.xand4.x-InstallingthePackage" rel="nofollow">
          Installing the Package
        </a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#InteractingwithcaCORELexEVS3.xand4.x-SearchParadigm" rel="nofollow">
      Search Paradigm
    </a>
    <ul>
      <li>
        <a href="#InteractingwithcaCORELexEVS3.xand4.x-QueryingtheSystem" rel="nofollow">
          Querying the System
        </a>
      </li>
      <li>
        <a href="#InteractingwithcaCORELexEVS3.xand4.x-QueryOptions" rel="nofollow">
          QueryOptions
        </a>
      </li>
      <li>
        <a href="#InteractingwithcaCORELexEVS3.xand4.x-ExamplesofUse" rel="nofollow">
          Examples of Use
        </a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#InteractingwithcaCORELexEVS3.xand4.x-WebServicesAPI" rel="nofollow">
      Web Services API
    </a>
    <ul>
      <li>
        <a href="#InteractingwithcaCORELexEVS3.xand4.x-Configuration" rel="nofollow">
          Configuration
        </a>
      </li>
      <li>
        <a href="#InteractingwithcaCORELexEVS3.xand4.x-BuildingaJavaSOAPClient" rel="nofollow">
          Building a Java SOAP Client
        </a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#InteractingwithcaCORELexEVS3.xand4.x-XML-HTTPAPI" rel="nofollow">
      XML-HTTP API
    </a>
    <ul>
      <li>
        <a href="#InteractingwithcaCORELexEVS3.xand4.x-ServiceLocationandSyntax" rel="nofollow">
          Service Location and Syntax
        </a>
      </li>
      <li>
        <a href="#InteractingwithcaCORELexEVS3.xand4.x-ExamplesofUse.1" rel="nofollow">
          Examples of Use
        </a>
      </li>
      <li>
        <a href="#InteractingwithcaCORELexEVS3.xand4.x-WorkingwithResultSets" rel="nofollow">
          Working with Result Sets
        </a>
      </li>
    </ul>
  </li>
  <li>
    <a href="#InteractingwithcaCORELexEVS3.xand4.x-DistributedLexBIGAPI" rel="nofollow">
      Distributed LexBIG API
    </a>
    <ul>
      <li>
        <a href="#InteractingwithcaCORELexEVS3.xand4.x-Overview" rel="nofollow">
          Overview
        </a>
      </li>
      <li>
        <a href="#InteractingwithcaCORELexEVS3.xand4.x-Architecture" rel="nofollow">
          Architecture
        </a>
      </li>
      <li>
        <a href="#InteractingwithcaCORELexEVS3.xand4.x-LexBIGAnnotations" rel="nofollow">
          LexBIG Annotations
        </a>
      </li>
      <li>
        <a href="#InteractingwithcaCORELexEVS3.xand4.x-AspectOrientedProgrammingProxies" rel="nofollow">
          Aspect Oriented Programming Proxies
        </a>
      </li>
      <li>
        <a href="#InteractingwithcaCORELexEVS3.xand4.x-LexBIGAPIDocumentation" rel="nofollow">
          LexBIG API Documentation
        </a>
      </li>
      <li>
        <a href="#InteractingwithcaCORELexEVS3.xand4.x-LexBIGInstallationandConfiguration" rel="nofollow">
          LexBIG Installation and Configuration
        </a>
      </li>
      <li>
        <a href="#InteractingwithcaCORELexEVS3.xand4.x-ExampleofUse" rel="nofollow">
          Example of Use
        </a>
      </li>
    </ul>
  </li>
</ul>
<h2 id="InteractingwithcaCORELexEVS3.xand4.x-caCORELexEVSComponents">
  caCORE LexEVS Components
</h2>
The caCORE LexEVS API is a public domain, open source wrapper that provides full access to the LexBIG Terminology Server. LexBIG hosts the NCI Thesaurus, the NCI Metathesaurus, and several other vocabularies. Java clients accessing the NCI Thesaurus and Metathesaurus vocabularies communicate their requests via the open source caCORE LexEVS APIs, as shown in Overview of the caCORE LexEVS 4.0 release components.
<img alt="Diagram showing an overview of the caCORE LexEVS 4.0 release components" src="https://wiki.nci.nih.gov/download/attachments/embedded-page/LexEVS/Interacting%20with%20caCORE%20LexEVS%203.x%20and%204.x/Overview_LexEVS_4.0_Release_Components.jpg?api=v2">
The open source interfaces provided as part of caCORE LexEVS 5.x include Java APIs, a SOAP interface, and an HTTP REST interface. The Java APIs are based on the EVS 3.2 object model and the LexBIG Service object model.

The EVS 3.2 model, exposed as part of caCORE 3.2, has been re-released with LexBIG as the back-end terminology service in place of the proprietary Apelon DTS back end. The SOAP and HTTP REST interfaces are also based on the 3.2 object model. The SDK 4.0 was used to generate the EVS 3.2 Java API, as well as the SOAP and HTTP REST interfaces.

The only difference between the EVS 3.2 API exposed as part of the caCORE LexEVS 5.x and the API exposed as part of caCORE 3.2 is the back-end terminology server used to retrieve the vocabulary data. The interface (API calls) are the same and should only require minor adjustments to user applications.

NoteYou cannot integrate caCORE 3.2 components with caCORE LexEVS 5.x. If you used multiple components of caCORE 3.2 (for example, EVS with caDSR), you need to continue to work with the caCORE 3.2 release until the other caCORE 4.0 components are available.

The LexBIG object model was developed by the Mayo Clinic. In its native form, the associated API assumes a local, non-distributed means of access. With caCORE LexEVS 5.x, a proxy layer enables EVS API clients to access the native LexBIG API from anywhere without having to worry about the underlying data sources. This is called the Distributed LexBIG (DLB) API.

The DLB Adapter is another option for caCORE LexEVS 5.x clients who choose to interface directly with the LexBIG API. This is essentially a set of convenience methods intended to simplify the use of the LexBIG API. For example, a series of method calls against the DLB API might equate to a single method call to the DLB Adapter.

NoteThe DLB Adapter is not intended to represent a complete set of convenience methods. As part of the caCORE LexEVS 5.x release, the intention is that users will work with the DLB API and suggest useful methods of convenience to the EVS Development Team.
<h2 id="InteractingwithcaCORELexEVS3.xand4.x-LexEVSDataSources">
  LexEVS Data Sources
</h2>
The LexEVS data source is the open source LexBIG terminology server. EVS clients interface with the LexBIG API to retrieve desired vocabulary data. The EVS provides the NCI with services and resources for controlled biomedical vocabularies, including the NCI Thesaurus and the NCI Metathesaurus.
<h3 id="InteractingwithcaCORELexEVS3.xand4.x-NCIThesaurus">
  NCI Thesaurus
</h3>
The NCI Thesaurus is composed of over 27,000 concepts represented by about 78,000 terms. The Thesaurus is organized into 18 hierarchical trees covering areas such as Neoplasms, Drugs, Anatomy, Genes, Proteins, and Techniques. These terms are deployed by the NCI in its automated systems for uses such as key wording and database coding.
<h3 id="InteractingwithcaCORELexEVS3.xand4.x-NCIMetathesaurus">
  NCI Metathesaurus
</h3>
The NCI Metathesaurus maps terms from one standard vocabulary to another, facilitating collaboration, data sharing, and data pooling for clinical trials and scientific databases. The Metathesaurus is based on the Unified Medical Language System (UMLS) developed by the National Library of Medicine (NLM). It is composed of over 70 biomedical vocabularies.
<h2 id="InteractingwithcaCORELexEVS3.xand4.x-InstallingandConfiguringtheLexEVS5.0JavaAPI">
  Installing and Configuring the LexEVS 5.0 Java API
</h2>
The LexEVS 5.0 Java API bundled with the caCORE LexEVS 5.x release provides direct access to domain objects and all service methods. Because caCORE LexEVS is natively built in Java, this API provides the fullest set of features and capabilities.

The EVS API home page provides a user interface (UI) to the Java API. The interface is available at
<a href="http://lexevsapi.nci.nih.gov/lexevsapi50" rel="nofollow">
  http://lexevsapi.nci.nih.gov/lexevsapi50
</a>
.

NoteThe caCORE 3.2 release also provides an EVS 3.2 Java client API. The difference between the 3.2 and the 4.x clients is the back-end terminology server. caCORE 3.2 uses the proprietary Apelon DTS and caCORE LexEVS 4.x uses LexBIG. The API is the same and should only require minor updates to a client application wanting to migrate to the EVS 3.2 Java API provided with caCORE LexEVS 5.x.
<h3 id="InteractingwithcaCORELexEVS3.xand4.x-SoftwareRequirements">
  Software Requirements
</h3>
The caCORE LexEVS Java 3.2 API uses the following software on the client machine (caCORE LexEVS Java API client software).
<table>
  <tbody>
    <tr>
      <th>
        Software
      </th>
      <th>
        Version
      </th>
      <th>
        Required?
      </th>
    </tr>
    <tr>
      <td>
        Java 2 Platform Standard Edition Software 5.0 Development Kit (JDK 5.0)
      </td>
      <td>
        1.5.0 or higher
      </td>
      <td>
        Yes
      </td>
    </tr>
    <tr>
      <td>
        Apache Ant
      </td>
      <td>
        1.6.5 or higher
      </td>
      <td>
        Yes
      </td>
    </tr>
  </tbody>
</table>
<h2 id="InteractingwithcaCORELexEVS3.xand4.x-DownloadingtheJavaAPIClientPackage">
  Downloading the Java API Client Package
</h2>
The client package is available on the NCICB Web site. To download it, follow these steps:
<ol>
  <li>
    Using your browser, go to
    <a href="http://ncicb.nci.nih.gov" rel="nofollow">
      http://ncicb.nci.nih.gov
    </a>
    .
  </li>
  <li>
    On the left navigation bar of the NCICB welcome page, click the more link to the right of the DOWNLOADS category (Downloads section of the NCICB Web site).
    <img alt="Screenshot showing the downloads section of the NCICB Web site in the left navigation bar" src="https://wiki.nci.nih.gov/download/attachments/embedded-page/LexEVS/Interacting%20with%20caCORE%20LexEVS%203.x%20and%204.x/NCICB_Website_Downloads_Section.jpg?api=v2">
  </li>
  <li>
    When prompted, enter your name, e-mail address, and institution name.
  </li>
  <li>
    Click Enter the Download Area.
  </li>
  <li>
    Read and accept the license agreement.
  </li>
  <li>
    On the caCORE LexEVS downloads page, download the EVS Zip file from the Primary Distribution section.
  </li>
</ol>
<h3 id="InteractingwithcaCORELexEVS3.xand4.x-InstallingthePackage">
  Installing the Package
</h3>
After downloading the caCORE LexEVS client package, extract the contents of the downloadable archive to a directory on your hard drive (for example, c:\evsapi on Windows or /usr/local/evsapi on Linux).

The extraction includes the directories and files listed below. This table shows the extracted directories and files in caCORE LexEVS client package.
<table>
  <tbody>
    <tr>
      <th>
        Directory
      </th>
      <th>
        Files
      </th>
      <th>
        Description
      </th>
      <th>
        Component
      </th>
    </tr>
    <tr>
      <td>
        ./build
      </td>
      <td>
        build.xml
      </td>
      <td>
        Ant build file
      </td>
      <td>
        Build file
      </td>
    </tr>
    <tr>
      <td>
        ./conf
      </td>
      <td>
        application-config-client.xml
      </td>
      <td>
        –
      </td>
      <td>
        –
      </td>
    </tr>
    <tr>
      <td></td>
      <td>
        xml-mapping.xml
      </td>
      <td>
        –
      </td>
      <td>
        –
      </td>
    </tr>
    <tr>
      <td></td>
      <td>
        log4j.properties.xml
      </td>
      <td>
        Logging utilities configuration properties
      </td>
      <td>
        –
      </td>
    </tr>
    <tr>
      <td></td>
      <td>
        *.xsd
      </td>
      <td>
        –
      </td>
      <td>
        –
      </td>
    </tr>
    <tr>
      <td>
        ./lib
      </td>
      <td>
        spring.jar
      </td>
      <td>
        Spring framework
      </td>
      <td>
        HTTP remoting
      </td>
    </tr>
    <tr>
      <td></td>
      <td>
        acegi-security-1.0.4.jar
      </td>
      <td>
        Spring Security
      </td>
      <td>
        –
      </td>
    </tr>
    <tr>
      <td></td>
      <td>
        asm.jar
      </td>
      <td>
        –
      </td>
      <td>
        –
      </td>
    </tr>
    <tr>
      <td></td>
      <td>
        antlr-2.7.6.jar
      </td>
      <td>
        Apache Ant
      </td>
      <td>
        –
      </td>
    </tr>
    <tr>
      <td></td>
      <td>
        log4j-1.2.14.jar
      </td>
      <td>
        Logging utilities
      </td>
      <td>
        Logging
      </td>
    </tr>
    <tr>
      <td></td>
      <td>
        commons-*.jar
      </td>
      <td>
        Various Apache Commons utilities
      </td>
      <td>
        Utilities
      </td>
    </tr>
    <tr>
      <td></td>
      <td>
        lexevsapi50-beans.jar
      </td>
      <td>
        Holder for Generated Beans (other than the Castor-generated LexBIG/LexGrid beans). Currently empty.
      </td>
      <td>
        –
      </td>
    </tr>
    <tr>
      <td></td>
      <td>
        lexevsapi50-framework.jar
      </td>
      <td>
        caCORE LexEVS framework
      </td>
      <td>
        –
      </td>
    </tr>
    <tr>
      <td></td>
      <td>
        lexbig.jar
      </td>
      <td>
        LexBIG classes. Contains the Castor-generated LexBIG/LexGrid domain Objects.
      </td>
      <td>
        –
      </td>
    </tr>
    <tr>
      <td></td>
      <td>
        lucene*.jar
      </td>
      <td>
        Index search
      </td>
      <td>
        LexBIG
      </td>
    </tr>
    <tr>
      <td></td>
      <td>
        castor-1.0.2.jar
      </td>
      <td>
        Castor serializer/deserializer
      </td>
      <td>
        XML conversion
      </td>
    </tr>
    <tr>
      <td></td>
      <td>
        xercesImpl.jar
      </td>
      <td>
        Apache Xerces XML parser
      </td>
      <td>
        –
      </td>
    </tr>
    <tr>
      <td></td>
      <td>
        sdk*.jar
      </td>
      <td>
        Base caCORE SDK functionality
      </td>
      <td>
        –
      </td>
    </tr>
  </tbody>
</table>
The following files are required to use the Java API:
<ul>
  <li>
    all of the files in the conf directory, and
  </li>
  <li>
    all of the jar files in the lib directory of the caCORE LexEVS client package.
  </li>
</ul>
When building applications, include these files in the Java classpath. The included build.xml file demonstrates how to do this when using Ant for command-line builds. If you are using an integrated development environment (IDE) such as Eclipse, refer to the tool&#39;s documentation for information on how to set the classpath.
<h2 id="InteractingwithcaCORELexEVS3.xand4.x-SearchParadigm">
  Search Paradigm
</h2>
The caCORE LexEVS architecture includes a service layer that provides a single, common access paradigm to clients that use any of the provided interfaces. As an object-oriented middleware layer designed for flexible data access, caCORE LexEVS relies heavily on strongly typed objects and an object-in/object-out mechanism.

Accessing and using a caCORE LexEVS system requires the following steps:
<ol>
  <li>
    Ensure that the client application has access to the objects in the domain space.
  </li>
  <li>
    Formulate the query criteria using the domain objects.
  </li>
  <li>
    Establish a connection to the server.
  </li>
  <li>
    Submit the query objects and specify the desired class of objects to be returned.
  </li>
  <li>
    Use and manipulate the result set as desired.
  </li>
</ol>
caCORE LexEVS systems use four native application programming interfaces (APIs). Each interface uses the same paradigm to provide access to the caCORE LexEVS domain model, with minor changes specific to the syntax and structure of the clients. The following sections describe each API, identify installation and configuration requirements, and provide code examples.

The sequence diagram that follows shows the caCORE 4.0 LexEVS API search mechanism implemented to access the NCI EVS vocabularies.
<img alt="Sequence diagram showing the caCORE 4.0 LexEVS API search mechanism" src="https://wiki.nci.nih.gov/download/attachments/embedded-page/LexEVS/Interacting%20with%20caCORE%20LexEVS%203.x%20and%204.x/caCORE_4.0_LexEVS_API_Search_Mechanism.jpg?api=v2">
<h3 id="InteractingwithcaCORELexEVS3.xand4.x-QueryingtheSystem">
  Querying the System
</h3>
LexEVS conforms to the caCORE SDK API - for more information see : (Link to caCORE SDK doc)
<h3 id="InteractingwithcaCORELexEVS3.xand4.x-QueryOptions">
  QueryOptions
</h3>
QueryOptions (link to javadoc) are designed to give the user extra control over the query before it is sent to the system. QueryOptions may be used to modify a query in these ways:
<ul>
  <li>
    &#39;CodingScheme&#39; - Restricts the query to the specified Coding Scheme, instead of querying every available Coding Scheme.
  </li>
  <li>
    CodingSchemeVersionOrTag&#39; - Restricts the query to the specified Version of the Coding Scheme. Note that:
    <ul>
      <li>
        This may NOT be specified without also specifying the &#39;CodingScheme&#39; attribute.
      </li>
      <li>
        If left unset, it will default to the version of the Coding Scheme tagged as &#34;PRODUCTION&#34; in the system.
      </li>
    </ul>
  </li>
  <li>
    &#39;SecurityTokens&#39; - Security Tokens to use with the specified query. These Security Tokens are scoped to the current query ONLY. An subsequent queries will also need to specify the necessary Query Options.
  </li>
  <li>
    &#39;LazyLoad&#39; - Some high use-case model Objects have bee &#39;lazy-load&#39; enabled. This means that some attributes and associations of a model Object may not be fully populated when returned to the user. This allows for faster query times. This defaults to false, meaning that all attributes and associations will be eagerly fetched by the server and model Objects will always be fully populated. To enable this on applicable Objects, set to true.
    Note Lazy Loading may only be used in conjunction with specifying a Coding Scheme and Version with the &#39;CodingScheme&#39; and &#39;CodingSchemeVersionOrTag&#39; attributes above.
  </li>
  <li>
    &#39;ResultPageSize&#39; - the page size of results to return. The higher the number, the more results the system will return to the user at once. The client will request the next group of query results transparenly. This parameter is useful for performance tuning. For example, if a query returns a result of10,000 Objects, a &#39;ResultPageSize&#39; of &#39;1000&#39; would make 10 calls to the server returning a page of 1000 results each time. If left unset, this value will default to the default set Page Size (LINK CACORE SDK GUIDE page 65)
  </li>
</ul>
<h3 id="InteractingwithcaCORELexEVS3.xand4.x-ExamplesofUse">
  Examples of Use
</h3>
Example 4.1: Query By Example with No Query Options



1  public static void main(String[] args)
2  {
3      try {
4          LexEVSApplicationService appService =
5            (LexEVSApplicationService)ApplicationServiceProvider.
6             getApplicationService(&#34;EvsServiceInfo&#34;);
7          Entity entity = new Entity()
8          entity.setEntityCode(&#34;C1234&#34;);
9          List&amp;lt;Entity&amp;gt; list = appService.search(Entity.class, entity);
10     } catch(ApplicationException ex){
11     }
12  }



The following table explains specific statements in the code by line number.
<table>
  <tbody>
    <tr>
      <th>
        Line Number
      </th>
      <th>
        Explanation
      </th>
    </tr>
    <tr>
      <td>
        4
      </td>
      <td>
        Creates an instance of a class that implements the LexEVSApplicationService interface. This interface defines the service methods used to access data objects.
      </td>
    </tr>
    <tr>
      <td>
        7
      </td>
      <td>
        Construct the Query By Example Object and populate it with the desired search critieria. For this example, seach for any &#39;Entity&#39; with an &#39;entityCode&#39; attribute equaling &#39;C1234&#39;.
      </td>
    </tr>
    <tr>
      <td>
        9
      </td>
      <td>
        Calls the search method of the LexEVSApplicationService  object. This method returns a List Collection. This list will contain all of the &#39;Entity&#39; Objects that match the search critieria. It this case, it will return all &#39;Entity&#39; Objects with an &#39;entityCode&#39; of &#34;C1234&#34;.
      </td>
    </tr>
  </tbody>
</table>
Example 4.2: Query By Example with Query Options



1  public static void main(String[] args)
2  {
3     try {
4        LexEVSApplicationService appService =
5           (LexEVSApplicationService)ApplicationServiceProvider.
6           getApplicationService(&#34;EvsServiceInfo&#34;);
7           QueryOptions queryOptions = new QueryOptions();
8           queryOptions.setCodingScheme(&#34;NCI Thesaurus&#34;);
9           CodingSchemeVersionOrTag csvt = new CodingSchemeVersionOrTag();
10          csvt.setVersion(&#34;09.10d&#34;);
11          queryOptions.setCodingSchemeVersionOrTag(csvt);
12        Entity entity = new Entity()
13        entity.setEntityCode(&#34;C1234&#34;);
14        List&amp;lt;Entity&amp;gt; list = appService.search(Entity.class, entity, queryOptions);
15      } catch(ApplicationException ex){
16      }
17  }



The following table explains specific statements in the code by line number.
<table>
  <tbody>
    <tr>
      <th>
        Line Number
      </th>
      <th>
        Explanation
      </th>
    </tr>
    <tr>
      <td>
        4
      </td>
      <td>
        Creates an instance of a class that implements the LexEVSApplicationService interface. This interface defines the service methods used to access data objects.
      </td>
    </tr>
    <tr>
      <td>
        7
      </td>
      <td>
        Construct the QueryOptions Object.
      </td>
    </tr>
    <tr>
      <td>
        8
      </td>
      <td>
        Populate the QueryOptions with the desired Coding Scheme.
      </td>
    </tr>
    <tr>
      <td>
        9
      </td>
      <td>
        Construct a CodingSchemeVersionOrTag Object.
      </td>
    </tr>
    <tr>
      <td>
        10
      </td>
      <td>
        Populate the CodingSchemeVersionOrTag Object with the desired Version.
      </td>
    </tr>
    <tr>
      <td>
        11
      </td>
      <td>
        Populate the QueryOptions with the above CodingSchemeVersionOrTag Object.
      </td>
    </tr>
    <tr>
      <td>
        12
      </td>
      <td>
        Construct the Query By Example Object and populate it with the desired search critieria. For this example, seach for any &#39;Entity&#39; with an &#39;entityCode&#39; attribute equaling &#39;C1234&#39;.
      </td>
    </tr>
    <tr>
      <td>
        14
      </td>
      <td>
        Calls the search method of the LexEVSApplicationService  object, along with the QueryOptions. This method returns a List Collection. This list will contain all of the &#39;Entity&#39; Objects that match the search critieria, while being further modified by the QueryOptions. It this case, it will return all &#39;Entity&#39; Objects with an &#39;entityCode&#39; of &#34;C1234&#34; belonging to the CodingScheme &#34;NCI Thesaurus&#34; Version &#34;09.10d&#34;.
      </td>
    </tr>
  </tbody>
</table>
<h2 id="InteractingwithcaCORELexEVS3.xand4.x-WebServicesAPI">
  Web Services API
</h2>
The caCORE LexEVS Web Services API enables access to caCORE LexEVS data and vocabulary data from development environments where the Java API cannot be used, or where use of XML Web services is more desirable. This includes non-Java platforms and languages such as Perl, C/C++, .NET framework (C#, VB.Net), and Python.

The Web services interface can be used in any language-specific application that provides a mechanism for consuming XML Web services based on the Simple Object Access Protocol (SOAP). In those environments, connecting to caCORE LexEVS can be as simple as providing the end-point URL. Some platforms and languages require additional client-side code to handle the implementation of the SOAP envelope and the resolution of SOAP types.To view a list of packages that cater to different programming languages, visit
<a href="http://www.w3.org/TR/SOAP/" rel="nofollow">
  http://www.w3.org/TR/SOAP/
</a>
and
<a href="http://www.soapware.org/" rel="nofollow">
  http://www.soapware.org/
</a>
.

To maximize standards-based interoperability, the caCORE Web service conforms to the Web Services Interoperability Organization (WS-I) basic profile. The WS-I basic profile provides a set of non-proprietary specifications and implementation guidelines that enable interoperability between diverse systems. For more information about WS-I compliance, visit
<a href="http://www.ws-i.org" rel="nofollow">
  http://www.ws-i.org
</a>
.

On the server side, Apache Axis is used to provide SOAP-based, inter-application communication. Axis provides the appropriate serialization and deserialization methods for the JavaBeans to achieve an application-independent interface. For more information about Axis, visit
<a href="http://ws.apache.org/axis/" rel="nofollow">
  http://ws.apache.org/axis/
</a>
.
<h3 id="InteractingwithcaCORELexEVS3.xand4.x-Configuration">
  Configuration
</h3>
The caCORE/LexEVS WSDL file is located at
<a href="http://lexevsapi.nci.nih.gov/lexevsapi50/services/lexevsapi50Service?wsdl" rel="nofollow">
  http://lexevsapi.nci.nih.gov/lexevsapi50/services/lexevsapi50Service?wsdl
</a>
. In addition to describing the protocols, ports, and operations exposed by the caCORE LexEVS Web service, this file can be used by a number of IDEs and tools to generate stubs for caCORE LexEVS objects. This enables code on different platforms to instantiate native objects for use as parameters and return values for the Web service methods. For more information on how to use the WSDL file to generate class stubs, consult the specific documentation for your platform.

The caCORE LexEVS Web services interface has a single end point called lexevsapi50Service, which is located at
<a href="http://lexevsapi.nci.nih.gov/lexevsapi50/services/lexevsapi50Service" rel="nofollow">
  http://lexevsapi.nci.nih.gov/lexevsapi50/services/lexevsapi50Service
</a>
. Client applications should use this URL to invoke Web service methods.
<h3 id="InteractingwithcaCORELexEVS3.xand4.x-BuildingaJavaSOAPClient">
  Building a Java SOAP Client
</h3>
LexEVSAPI provides a tool to create a Java SOAP client capable of connecting to a LexEVSAPI SOAP service.

In the ./webServiceSoapClient contains a build.xml file that will construct a LexEVSAPI SOAP client.  Before building, you may edit this build.xml file to customize the build process. Editable properties include &#39;wsdlURL&#39; and &#39;webServiceNamespace&#39;. An example configuration is below:


&lt;property name=&#34;wsdlURL&#34; value=&#34;http://bmidev4:8180/lexevsapi50/services/lexevsapi50Service?wsdl&#34;/&gt;
&lt;property name=&#34;webServiceNamespace&#34; value=&#34;http://bmidev4:8180/lexevsapi50/services/lexevsapi50Service&#34;/&gt;


To build the client, use the command ant all from the ./webServiceSoapClient directory.
<h2 id="InteractingwithcaCORELexEVS3.xand4.x-XML-HTTPAPI">
  XML-HTTP API
</h2>
The caCORE LexEVS XML-HTTP API, based on the REST (Representational State Transfer) architectural style, provides a simple interface using the HTTP protocol. In addition to its ability to be invoked from most Internet browsers, developers can use this interface to build applications that do not require any programming overhead other than an HTTP client. This is particularly useful for developing Web applications using AJAX (Asynchronous JavaScript and XML).
<h3 id="InteractingwithcaCORELexEVS3.xand4.x-ServiceLocationandSyntax">
  Service Location and Syntax
</h3>
The CORE EVS XML-HTTP interface uses the following URL syntax:


http://{server}/{servlet}?query={returnClass}&amp;{criteria}
	&amp;startIndex={index}
	&amp;codingSchemeName={codingSchemeName}
	&amp;codingSchemeVersion={codingSchemeVersion}


The following table explains the URL syntax used by the caCORE LexEVS XML-HTTP interface, indicates whether specific elements are required, and gives examples.
<table>
  <tbody>
    <tr>
      <th>
        Element
      </th>
      <th>
        Meaning
      </th>
      <th>
        Required
      </th>
      <th>
        Example
      </th>
    </tr>
    <tr>
      <td>
        server
      </td>
      <td>
        Name of the Web server on which the caCORE LexEVS 5.0 Web application is deployed.
      </td>
      <td>
        Yes
      </td>
      <td>
        lexevsapi.nci.nih.gov/lexevsapi50
      </td>
    </tr>
    <tr>
      <td>
        servlet
      </td>
      <td>
        URI and name of the servlet that will accept the HTTP GET requests.
      </td>
      <td>
        Yes
      </td>
      <td>
        lexevsapi50/GetXML
        lexevsapi50/GetHTML
      </td>
    </tr>
    <tr>
      <td>
        returnClass
      </td>
      <td>
        Class name indicating the type of objects that this query should return.
      </td>
      <td>
        Yes
      </td>
      <td>
        –
      </td>
    </tr>
    <tr>
      <td>
        criteria
      </td>
      <td>
        Search request criteria describing the requested objects.
      </td>
      <td>
        Yes
      </td>
      <td>
        –
      </td>
    </tr>
    <tr>
      <td>
        index
      </td>
      <td>
        Starting index of the result set.
      </td>
      <td>
        No
      </td>
      <td>
        –
      </td>
    </tr>
    <tr>
      <td>
        codingSchemeName
      </td>
      <td>
        Restrict the query to a specific Coding Scheme Name.
      </td>
      <td>
        No
      </td>
      <td>
        –
      </td>
    </tr>
    <tr>
      <td>
        codingSchemeVersion
      </td>
      <td>
        Restrict the query to a specific Coding Scheme Version.
      </td>
      <td>
        No
        NOTE: Must be used in conjunction with a &#39;codingSchemeName&#39;
      </td>
      <td>
        –
      </td>
    </tr>
  </tbody>
</table>
The caCORE LexEVS architecture currently provides two servlets that accept incoming requests:
<ul>
  <li>
    GetXML returns results in an XML format that can be parsed and consumed by most programming languages and many document authoring and management tools.
  </li>
  <li>
    GetHTML presents result using a simple HTML interface that can be viewed by most modern Internet browsers.
  </li>
</ul>
Within the request string of the URL, the criteria element specifies the search criteria using XQuery-like syntax. Within this syntax, square brackets (/[ /]) represent attributes and associated roles of a class, the at symbol (@) signals an attribute name/value pair, and a forward slash character
<img src="https://wiki.nci.nih.gov/s/-y6pnqc/8804/nk8x3c/_/images/icons/emoticons/check.svg" alt="(tick)"/>
specifies nested criteria.

Criteria statements in XML-HTTP queries generally use the following syntax (although you can also build more complex statements):


{ClassName}[@{attributeName}={value}] [@{attributeName}={value}]...

ClassName}[@{attributeName}={value}]/

{ClassName}[@{attributeName}={value}]/...


The following table explains the syntax for criteria statements within XML-HTTP queries and gives examples.
<table>
  <tbody>
    <tr>
      <th>
        Parameter
      </th>
      <th>
        Meaning
      </th>
      <th>
        Example
      </th>
    </tr>
    <tr>
      <td>
        ClassName
      </td>
      <td>
        The name of a class.
      </td>
      <td>
        Entity
      </td>
    </tr>
    <tr>
      <td>
        attributeName
      </td>
      <td>
        The name of an attribute of the return class or an associated class
      </td>
      <td>
        _entityCode
      </td>
    </tr>
    <tr>
      <td>
        value
      </td>
      <td>
        The value of an attribute.
      </td>
      <td>
        C123*
      </td>
    </tr>
  </tbody>
</table>
<h3 id="InteractingwithcaCORELexEVS3.xand4.x-ExamplesofUse.1">
  Examples of Use
</h3>
The examples in the following table demonstrate the usage of the XML-HTTP interface. In actual usage, these queries would either be submitted by a block of code or entered in the address bar of a Web browser. The servlet name GetXML in each of the examples can be replaced with GetHTML to view with layout and markup in a browser.
<table>
  <tbody>
    <tr>
      <th>
        Query
      </th>
      <td>
        http://evsapi.nci.nih.gov/evsapi41/GetXML?query=DescLogicConcept[_entityCode=C123*
      </td>
    </tr>
    <tr>
      <th>
        Semantic Meaning
      </th>
      <td>
        Find all objects of type Entity that contain an &#39;entityCode&#39; matching the pattern &#39;C123*&#39;.
      </td>
    </tr>
  </tbody>
</table>
<h3 id="InteractingwithcaCORELexEVS3.xand4.x-WorkingwithResultSets">
  Working with Result Sets
</h3>
Because HTTP is a stateless protocol, the caCORE LexEVS server cannot detect the context of any incoming request. Consequently, each invocation of GetXML or GetHTML must contain all of the information necessary to retrieve the request, regardless of previous requests. Developers should consider this when working with the XML-HTTP interface.
<ul>
  <li>
    Controlling the Start Index - To specify a specific start position in the result set, specify the &amp;startIndex parameter. This will scroll to the desired position within the set of results.
  </li>
  <li>
    Internal-Use Parameters - A number of parameters, such as &amp;resultCounter, &amp;pageSize, and &amp;page, are used 	internally by the system and are not designed to be set by the user.
  </li>
</ul>
NoteWhen specifying attribute values in the query string, note that use of the following characters generates an error:
[ ] / \ # &amp; %
<h2 id="InteractingwithcaCORELexEVS3.xand4.x-DistributedLexBIGAPI">
  Distributed LexBIG API
</h2>
<h3 id="InteractingwithcaCORELexEVS3.xand4.x-Overview">
  Overview
</h3>
In place of the existing EVS 3.2 object model, caCORE LexEVS is making a gradual transition toward a pure LexBIG back-end terminology server and exposure of the LexBIG Service object model. caCORE 3.2 and earlier required a custom API layer between external users of the system and the proprietary Apelon Terminology Server APIs. With the transition to LexBIG, caCORE LexEVS can publicly expose the open source terminology service API without requiring a custom API layer.
<h3 id="InteractingwithcaCORELexEVS3.xand4.x-Architecture">
  Architecture
</h3>
The LexBIG API is exposed by the LexEVS caCORE System for remote, distributed access (Figure 4.5). The caCORE System&#39;s LexEVSApplicationService class implements the LexBIGService interface, effectively exposing LexBIG via caCORE.

Since in many cases the objects returned from the LexBIGService are not merely beans, but full-fledged data access objects (DAOs), the caCORE LexEVS client is configured to proxy method calls into the LexBIG objects and forward them to the caCORE server so that they execute within the LexBIG environment.
<img alt="diagram showing the DLB Architecture" src="https://wiki.nci.nih.gov/download/attachments/embedded-page/LexEVS/Interacting%20with%20caCORE%20LexEVS%203.x%20and%204.x/DLB_Architecture.jpg?api=v2">
The DLB environment will be configured on the caCORE LexEVS Server (
<a href="http://lexevsapi.nci.nic.gov/lexevsapi50" rel="nofollow">
  http://lexevsapi.nci.nic.gov/lexevsapi50
</a>
). This will give the server access to the LexBIG database and other resources. The client must therefore go through the caCORE LexEVS server to access any LexBIG data.
<h3 id="InteractingwithcaCORELexEVS3.xand4.x-LexBIGAnnotations">
  LexBIG Annotations
</h3>
To address LexBIG DAOs, the LexBIG API integration incorporated the addition of (1) Java annotation marking methods that can be safely executed on the client side; and (2) classes that can be passed to the client without being wrapped by a proxy. The annotation is named @lgClientSideSafe. Every method in the LexBIG API that is accessible to the caCORE LexEVS user had to be considered and annotated if necessary.
<h3 id="InteractingwithcaCORELexEVS3.xand4.x-AspectOrientedProgrammingProxies">
  Aspect Oriented Programming Proxies
</h3>
LexBIG integration with caCORE LexEVS was accomplished using Spring Aspect Oriented Programming (AOP) to proxy the LexBIG classes and intercept calls to their methods. The caCORE LexEVS client wraps every object returned by the LexBIGService inside an AOP Proxy with advice from a LexBIGMethodInterceptor (&#34;the interceptor&#34;).

The interceptor is responsible for intercepting all client calls on the methods in each object. If a method is marked with the @lgClientSideSafe annotation, it proceeds normally. Otherwise, the object, method name, and parameters are sent to the caCORE LexEVS server for remote execution.
<img alt="Sequence diagram showing method interception" src="https://wiki.nci.nih.gov/download/attachments/embedded-page/LexEVS/Interacting%20with%20caCORE%20LexEVS%203.x%20and%204.x/Sequence_Diagram_Showing_Method_Interception.jpg?api=v2">
<h3 id="InteractingwithcaCORELexEVS3.xand4.x-LexBIGAPIDocumentation">
  LexBIG API Documentation
</h3>
The Mayo Clinic wrote the LexBIG 5.0 API. Documentation describing the LexBIG Service Model is available on the LexGRID Vocabulary Services for caBIG GForge site at
<a href="https://gforge.nci.nih.gov/frs/?group_id=14" rel="nofollow">
  https://gforge.nci.nih.gov/frs/?group_id=14
</a>
.
<h3 id="InteractingwithcaCORELexEVS3.xand4.x-LexBIGInstallationandConfiguration">
  LexBIG Installation and Configuration
</h3>
The DLB API is strictly a Java interface and requires Internet access for remote connectivity to the caCORE LexEVS server. Access to the DLB API requires access to the lexevsapi-client.jar file, available for download on the NCICB Web site. The lexevsapi-client.jar file needs to be available in the classpath. For more information, see the section,
<a href="https://wiki.nci.nih.gov/pages/viewpage.action?pageId=62427404" rel="nofollow">
  Installing and Configuring the LexEVS 5.0 Java API
</a>
.
<h3 id="InteractingwithcaCORELexEVS3.xand4.x-ExampleofUse">
  Example of Use
</h3>
Example 4.6: Using the DLB API

The following code sample shows use of the DLB API to retrieve the list of available coding schemes in the LexBIG repository.



1  public class Test {
2      /**
3    * Initialize program variables
4    */
5
6    private String codingScheme = null;
7    private String version = null;
8
9    DLBAdapter adapter = null;
10    LexBIGService lbSvc;
11
12    public Test(String codingScheme, String version)
13    {
14        //Set the LexEVS URL (for remote access)
15        String evsUrl = &#34;http://lexevsapi.nci.nih.gov/lexevsapi50/http/remoteService&#34;;
16
17        boolean isRemote = true;
18        this.codingScheme = codingScheme;
19        this.version = version;
20
21        // Get the LexBIG service reference from LexEVS Application Service
22        lbSvc = (LexEVSApplicationService)ApplicationServiceProvider.                 getApplicationServiceFromUrl(evsUrl, &#34;EvsServiceInfo&#34;);
23
24        // Set the vocabulary to work with
25        Boolean retval = adapter.setVocabulary(codingScheme);
26
27        codingSchemeMap = new HashMap();
28        try {

32            // Using the LexBIG service, get the supported coding schemes
33            CodingSchemeRenderingList csrl = lbSvc.getSupportedCodingSchemes();
34
35            // Get the coding scheme rendering
36            CodingSchemeRendering[] csrs = csrl.getCodingSchemeRendering();
37
38            // For each coding scheme rendering...
39            for (int i=0; i&amp;lt;csrs.length; i++) {
40                CodingSchemeRendering csr = csrs[i];
41
42                // Determine whether the coding scheme rendering is active or not
43                Boolean isActive = csr.getRenderingDetail().getVersionStatus()
.equals(CodingSchemeVersionStatus.ACTIVE);
44                if (isActive != null &amp;&amp; isActive.equals(Boolean.TRUE)) {
45
46                    // Get the coding scheme summary
47                    CodingSchemeSummary css = csr.getCodingSchemeSummary();
48
49                    // Get the coding scheme formal name
50                    String formalname = css.getFormalName();
51
52                    //Get the coding scheme version
53                    String representsVersion = css.getRepresentsVersion();
54                    CodingSchemeVersionOrTag vt = new;
55                    CodingSchemeVersionOrTag();
56                    vt.setVersion(representsVersion);
57
58                    // Resolve coding scheme based on the formal name
59                    CodingScheme scheme = null;
60
61                    try {
62                    scheme =
lbSvc.resolveCodingScheme(formalname, vt);
63                        if (scheme != null)
64                        {
65                            codingSchemeMap.put((Object) formalname, (Object) scheme);
66                        }
67                        } catch (Exception e) {
68                        // Resolve coding scheme based on the URI
69                        String uri = css.getCodingSchemeURI();
70                        try {
71                            scheme = lbSvc.resolveCodingScheme(uri, vt);
72                            if (scheme != null)
73                            {
74                                codingSchemeMap.put((Object) formalname, (Object) scheme);
75                            }
76                            } catch (Exception ex) {
77                            String localname = css.getLocalName();
78
79                            // Resolve coding scheme based on the local name
80                            try {
81                                scheme = lbSvc.resolveCodingScheme(localname, vt);
82                                if(scheme != null)
83                                {
84                                    codingSchemeMap.put((Object) formalname, (Object) scheme);
85                                }
86                                } catch (Exception e2) {
87                            }
88                        }
89                    }
90                }
91            }
92            } catch (Exception e) {
93            e.printStackTrace();
94        }
95    }
96
97    /**
98    *Main
99    */
100    public static void main (String[] args)
101    {
102        String name = &#34;NCI Thesaurus&#34;;
103        String version = &#34;06.12d&#34;;
104
105        // Instantiate the Test Class
106        Test test = new Test(name, version);
107    }
108} 